<!DOCTYPE html>
<html lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="description" content="iNaturalist Countries" />
<title>iNaturalist Countries</title>
<style>
   body { font:10pt Sans-Serif; }
   .tar { text-align:right; }
   #main { width:100%; }
   table, thead, tbody, tr, td { margin:0px; padding:3px; border-width:1px 0px;border-style:solid; border-color:lightgray; border-spacing:0px; border-collapse:collapse; }
   thead tr { font-weight:600; background:green; color:white; }
   tr { background:whitesmoke; }
   tr:nth-child(even) {background-color:white }
   a { text-decoration:none; }
   .button { font-size:18pt; }
   .button_inactive { font-size:18pt; opacity:0.5; }
</style>
</head>

<body>
<script>

//get parameters from the url
let winurlstr = window.location.href;
let winurlsearchstr = window.location.search;
let winurlexsearchstr = winurlstr.replace(winurlsearchstr,'');
let winurlparams = new URLSearchParams(winurlsearchstr.substring(1));
var stats = winurlparams.get('stats')||[];
var show = {};
show.observations = stats.includes('observations');
show.species = stats.includes('species');
show.observers = stats.includes('observers');
show.identifiers = stats.includes('identifiers');
winurlparams.delete('stats');
winurlparams.delete('place_id'); // will be set to individual countries
winurlparams.delete('page');
winurlparams.append('page',1);
winurlparams.delete('per_page');
winurlparams.append('per_page',0); // we don't actually need to return any detail records. we just need the total_records value returned in the response.

function fdate(str,dateonly=false) {
   str = str.replace(/t/i,' '); //replaces T (case insensitive) with a space
   if (dateonly) { str = str.split(' ')[0]; }
   else {
      str = str.replace(/([+-]\d{2}\:?\d{2})/,' ($1)'); //puts parenthesis around time zone offset
      str = str.replace(/z/i,' (+00:00)'); //replaces Z (case insensitve) with UTC
      str = str.replace('+00:00','Â±00:00');
   };
   return str;
};
function furl(url,txt=url) { return '<a href="'+url+'">'+txt+'</a>'; };
function fcomnum(n) { return n.toString().replace(/\B(?=(\d{3})+(?!\d))/g,',') };
function faddelem(etype,eparent=null,eclass=null,eid=null,ehtml=null,etext=null) {
   var eobj = document.createElement(etype);
   if (eclass!==null) { eobj.classList = eclass };
   if (eid!==null) { eobj.id = eid };
   if (ehtml!==null) { eobj.innerHTML = ehtml };
   if (etext!==null) { eobj.innerText = etext };
   if (eparent!==null) { eparent.appendChild(eobj); };
   return eobj;
};
function fgetname(ary,key) {
   var obj = ary.find(o=>o.id===key);
   return obj?obj.name:key;
};
function fgetwdinfo(ary,key) {
   var obj = ary.find(o=>o.isoCode.value===key);
   return obj ? {
      isoCode : obj.isoCode.value, 
      population : obj.population?obj.population.value:null,
      area : obj.area?obj.area.value:null,
      entity: obj.country?obj.country.value.substring(obj.country.value.lastIndexOf('/')+1):null,
      url: obj.country?obj.country.value:null
   } 
   : { isoCode:key };
};
function fround(num,places) {
   var n = num*1;
   return n.toFixed(places); 
};
function ffetch(url) {
   return fetch(url)
      .then((response) => {
         if (!response.ok) { throw new Error(response.status+': '+response.statusText); };
         return response.json();
      })
      .then((data) => { return data; })
      .catch((err) => { console.error(err); });
};
function delay(time,value) {
   return new Promise(function(resolve) { 
       setTimeout(resolve.bind(null, value), time)
       console.log('Pausing '+time+'ms...')
   });
}

var apiref = {};
apiref.observations = 'https://api.inaturalist.org/v1/docs/#!/Observations/get_observations';
apiref.species = 'https://api.inaturalist.org/v1/docs/#!/Observations/get_observations_species_counts';
apiref.identifiers = 'https://api.inaturalist.org/v1/docs/#!/Observations/get_observations_identifiers';
apiref.observers = 'https://api.inaturalist.org/v1/docs/#!/Observations/get_observations_observers';
faddelem('h1',document.body,null,null,'iNaturalist Countries');
faddelem('p',document.body,null,null,'By default, this page pulls back a list of countries set up in iNaturalist. It also will get population and area from Wikidata, if available, keying on ISO 3166-1 Alpha-2 Code. Optionally, it can pull back counts of observations, species, identifiers, and observers for each country. To get the extra statistics, add a "stats" parameter to the URL, and set it to a comma-separated list of values including "observations", "species", "identifiers", and/or "observers". These extra stats can also be filtered in the URL using the parameters available in the '+furl(apiref.observations,'observations')+', '+furl(apiref.species,'species')+', '+furl(apiref.identifiers,'identifiers')+', and '+furl(apiref.observers,'observers')+' API endpoints.');
faddelem('p',document.body,null,null,'For example, to add number of research-grade bird observations and associated observers to the list of countries, open '+furl(winurlexsearchstr+'?taxon_id=3&quality_grade=research&stats=observations,observers')+' in your browser.');
faddelem('p',document.body,null,null,'To adhere to recommended API request limits when getting the additional stats, this page will request one data point per second. Additionally, you should be careful of how often you use this page to get those additional stats so that you do not exceed the recommended maximum 10,000 daily API request limit. See the '+furl('https://www.inaturalist.org/pages/api+recommended+practices','API recommended practices page')+' for more information.');

// get places where the place type = country
// note that not all of these are countries. so we separately filter for admin level = 0 (since that filter doesn't exist in the API itself).
var apiurl = 'https://www.inaturalist.org/places.json?place_type=country&per_page=200';
var promiseary = [];
for (i=1;i<=2;i++) { // there shouldn't be more than 2 sets needed
   promiseary.push(ffetch(apiurl+'&page='+i));
};
Promise.all(promiseary).then(data=>{
   var placeary = [];
   for (d=0;d<data.length;d++) {
      for (p=0;p<data[d].length;p++) {
         if (data[d][p].admin_level===0) { placeary.push(data[d][p]); }
      };
   };
   return placeary;
})
// get the continents (parent places) associated with the countries
// also get population and area information from Wikidata. (after writing an appropriate sparql query using the Wikidata query service at https://query.wikidata.org/, the javascript code for below was taken more or less as suggested by the service.)
.then(async countries=>{
   var continents = [];
   for (i=0;i<countries.length;i++) {
      var c = countries[i].parent_id;
      if(!continents.includes(c)) { continents.push(c) };
   };
   var d = await ffetch('https://api.inaturalist.org/v1/places/'+continents);

   class SPARQLQueryDispatcher {
      constructor( endpoint ) {
         this.endpoint = endpoint;
      }
      query( sparqlQuery ) {
         const fullUrl = this.endpoint + '?query=' + encodeURIComponent( sparqlQuery );
         const headers = { 'Accept': 'application/sparql-results+json' };
         return fetch( fullUrl, { headers } ).then( body => body.json() );
      }
   }
   const endpointUrl = 'https://query.wikidata.org/sparql';
   const sparqlQuery = `SELECT ?isoCode ?countryLabel ?country ?population ?area WHERE {
       ?country wdt:P297 ?isoCode .
       OPTIONAL { ?country wdt:P1082 ?population } .
       OPTIONAL { ?country wdt:P2046 ?area } .
      #  OPTIONAL { ?country p:P2046/psn:P2046/wikibase:quantityAmount ?area } .
      SERVICE wikibase:label { bd:serviceParam wikibase:language "en". }
      }
      ORDER BY ?isoCode DESC(?population) ?area`;
   const queryDispatcher = new SPARQLQueryDispatcher( endpointUrl );
   var wd = await queryDispatcher.query( sparqlQuery );
  // .then( console.log );

   return [countries,d,wd];
})
// create the the country list
// if any stats are specified in the parameters, then create the cells to hold the data, but don't populate the cells at this point.
.then(data=>{
   var countries = data[0];
   var continents = data[1].results;
   var wd = data[2].results.bindings;
   if (!countries) {
      faddelem('p',document.body,null,null,'No results returned.');
      return;
   }
   // sort the list alphabetically by name
   countries.sort(function(a, b) { // sort by name
       if(a.name < b.name) { return -1; }
       if(a.name > b.name) { return 1; }
       return 0;
   });
   // table and headers
   var table = faddelem('table',document.body,null,'main');
   var thead = faddelem('thead',table);
   var hrow = faddelem('tr',thead);
   faddelem('td',hrow,null,null,'#');
   faddelem('td',hrow,null,null,'ID');
   faddelem('td',hrow,null,null,'Alpha-2 Code');
   faddelem('td',hrow,null,null,'Name');
//   faddelem('td',hrow,null,null,'display_name');
//   faddelem('td',hrow,null,null,'slug');
   faddelem('td',hrow,null,null,'Check List ID');
   faddelem('td',hrow,null,null,'Create Date');
   faddelem('td',hrow,null,null,'Update Date');
   faddelem('td',hrow,null,null,'Parent Place');
   faddelem('td',hrow,'tar',null,'Lat');
   faddelem('td',hrow,'tar',null,'Long');
   faddelem('td',hrow,'tar',null,'NE Lat');
   faddelem('td',hrow,'tar',null,'NE Long');
   faddelem('td',hrow,'tar',null,'SW Lat');
   faddelem('td',hrow,'tar',null,'SW Long');
//   faddelem('td',hrow,null,null,'source_id');
//   faddelem('td',hrow,null,null,'source_identifier');
//   faddelem('td',hrow,null,null,'source_name');
//   faddelem('td',hrow,null,null,'user_id');
//   faddelem('td',hrow,null,null,'woeid');
//   faddelem('td',hrow,null,null,'uuid');
   faddelem('td',hrow,'tar',null,'Wikidata ID');
   faddelem('td',hrow,'tar',null,'Population');
   faddelem('td',hrow,'tar',null,'Area (sq km)');
   if (show.observations) { faddelem('td',hrow,'tar',null,'Observations'); }
   if (show.species) { faddelem('td',hrow,'tar',null,'Species'); }
   if (show.identifiers) { faddelem('td',hrow,'tar',null,'Identifiers'); }
   if (show.observers) { faddelem('td',hrow,'tar',null,'Observers'); }

   // table rows
   var tbody = faddelem('tbody',table);
   for (var i=0; i<countries.length; i++) {
      var brow = faddelem('tr',tbody);
      faddelem('td',brow,null,null,i+1);
      faddelem('td',brow,null,null,furl('https://www.inaturalist.org/places/'+countries[i].id,countries[i].id));
      faddelem('td',brow,null,null,furl('https://www.iso.org/obp/ui/#iso:code:3166:'+countries[i].code,countries[i].code));
      faddelem('td',brow,null,null,furl('https://www.inaturalist.org/observations?place_id='+countries[i].id,countries[i].name));
//      faddelem('td',brow,null,null,countries[i].display_name);
//      faddelem('td',brow,null,null,countries[i].slug);
      faddelem('td',brow,null,null,countries[i].check_list_id?furl('https://www.inaturalist.org/check_lists/'+countries[i].check_list_id,countries[i].check_list_id):'');
      faddelem('td',brow,null,null,fdate(countries[i].created_at,true));
      faddelem('td',brow,null,null,fdate(countries[i].updated_at,true));
      faddelem('td',brow,null,null,countries[i].parent_id?furl('https://www.inaturalist.org/places/'+countries[i].parent_id,fgetname(continents,countries[i].parent_id)):'');
      faddelem('td',brow,'tar',null,fround(countries[i].latitude,4));
      faddelem('td',brow,'tar',null,fround(countries[i].longitude,4));
      faddelem('td',brow,'tar',null,fround(countries[i].nelat,4));
      faddelem('td',brow,'tar',null,fround(countries[i].nelng,4));
      faddelem('td',brow,'tar',null,fround(countries[i].swlat,4));
      faddelem('td',brow,'tar',null,fround(countries[i].swlng,4));
//      faddelem('td',brow,null,null,countries[i].source_id);
//      faddelem('td',brow,null,null,countries[i].source_identifier);
//      faddelem('td',brow,null,null,countries[i].source_name);
//      faddelem('td',brow,null,null,countries[i].user_id);
//      faddelem('td',brow,null,null,countries[i].woeid);
//      faddelem('td',brow,null,null,countries[i].uuid);
      var wdinfo = fgetwdinfo(wd,countries[i].code);
      faddelem('td',brow,'tar',null,wdinfo.entity?furl(wdinfo.url,wdinfo.entity):null);
      faddelem('td',brow,'tar',null,wdinfo.population?fcomnum(wdinfo.population):null);
      faddelem('td',brow,'tar',null,wdinfo.area?fcomnum(fround(wdinfo.area,1)):null);
      if (show.observations) { faddelem('td',brow,'tar','observations_'+countries[i].id); }
      if (show.species) { faddelem('td',brow,'tar','species_'+countries[i].id); }
      if (show.identifiers) { faddelem('td',brow,'tar','identifiers_'+countries[i].id); }
      if (show.observers) { faddelem('td',brow,'tar','observers_'+countries[i].id); }
   };
   return countries;
})
// if stats are specified then populate them
// recommended API request limits are 1 request per second. so this will wait 1 second between initiating each API request.
.then(async countries=>{
   var datatoget = [];
   if (show.observations) { datatoget.push({urlsuffix:'',tdid:'observations'}); };
   if (show.species) { datatoget.push({urlsuffix:'/species_counts',tdid:'species'}); };
   if (show.identifiers) { datatoget.push({urlsuffix:'/identifiers',tdid:'identifiers'}); };
   if (show.observers) { datatoget.push({urlsuffix:'/observers',tdid:'observers'}); };
   if (datatoget.length===0) { return; }

   for (var i=0; i<countries.length; i++) {
      for (var j=0; j<datatoget.length; j++) {
         await delay(1000);
         Promise.all([
            Promise.resolve(countries[i].id),
            Promise.resolve(datatoget[j].tdid),
            ffetch('https://api.inaturalist.org/v1/observations'+datatoget[j].urlsuffix+'?'+winurlparams+'&place_id='+countries[i].id)
         ])
         .then(results=>{ document.getElementById(results[1]+'_'+results[0]).innerText = (results[2]?fcomnum(results[2].total_results):'N/A'); });
      };
   };
});

</script>
</body>

</html>